<!DOCTYPE html>
<html>
  <head>
    <title>Super Markio</title>
  </head>

  <style>
    body {
      background: #000;
      margin: 0;
      padding: 10px;
    }

    #resources {
      display: none;
    }
  </style>

  <body>

    <canvas id="c"></canvas>

    <div id="resources">
      <img src="player-right.png" id="player-right">
      <img src="player-right-walk.png" id="player-right-walk">
      <img src="player-right-skid.png" id="player-right-skid">
      <img src="player-left.png" id="player-left">
      <img src="player-left-walk.png" id="player-left-walk">
      <img src="player-left-skid.png" id="player-left-skid">
    </div>

  </body>

  <script id="defineClass">
    (function() {
      function defineClass() {
        var kDefineClassMagicValue = 'defineClass_do_not_call_user_provided_constructor';
        var args = Array.prototype.slice.apply(arguments);
        var className, superClassName, constructor, properties;

        className = args.shift();
        if (typeof args[0] == 'string') {
          superClassName = args.shift();
        }
        if (typeof args[0] == 'function') {
          constructor = args.shift();
        } else if(superClassName) {
          constructor = window[superClassName].prototype.constructor;
        } else {
          constructor = function() {};
        }
        if (typeof args[0] == 'object') {
          properties = args.shift();
        } else {
          properties = {};
        }

        (function(className, superClassName, constructor, properties) {
          function theNewClass() {
            this.className = className;
            this.constructor = constructor;

            if (arguments[0] != kDefineClassMagicValue) {
              this.constructor.apply(this, arguments);
            }
          }

          if (superClassName) {
            theNewClass.prototype = new window[superClassName](kDefineClassMagicValue);
          }
          theNewClass.constructor = constructor;

          theNewClass.className = className;
          Object.keys(properties).forEach(function(key) {
            theNewClass.prototype[key] = properties[key];
          }.bind(this));

          window[className] = theNewClass;
        })(className, superClassName, constructor, properties);
      }
      window.defineClass = defineClass;
    })();
  </script>

  <script>
    (function() {
      console.log(+new Date);

      var kSMColorSkyBlue = '#A9FDF4';

      var kSMEngineFPS = 60;
      var kSMEngineBlockSize = 32;
      var kSMEngineGameWidth = 48; // should be 16 once scrolling is available
      var kSMEngineGameHeight = 12;
      var kSMFrameUnit = 1 / kSMEngineFPS;

      //  Player
      var kSMPlayerHeightPx = 32;
      var kSMPlayerWidthPx = 32;
      var kSMPlayerVerticalStateIdle = 'idle';
      var kSMPlayerVerticalStateJumping = 'jumping';
      var kSMPlayerVerticalStateFalling = 'falling';
      var kSMPlayerVerticalSpeed = 0;
      var kSMPlayerHorizontalStateIdle = 'idle';
      var kSMPlayerHorizontalStateLeft = 'left';
      var kSMPlayerHorizontalStateRight = 'right';
      var kSMPlayerHorizontalSpeed = 0;
      var kSMPlayerFaceLeft = 'left';
      var kSMPlayerFaceRight = 'right';

      //  Keycodes
      var kSMKeyAction = 90;
      var kSMKeyJump = 88;
      var kSMKeyLeft = 37;
      var kSMKeyUp = 378
      var kSMKeyRight = 39;
      var kSMKeyDown = 39;

      //  Physics
      var kSMPlayerInitialSpeed = 0.25; // in blocks-per-second
      var kSMPlayerWalkAcceleration = 1.0912;
      var kSMPlayerDeceleration = 0.95;
      var kSMPlayerWalkMaxBlocksPerSecond = 5;
      var kSMPlayerRunAcceleration = 1.0925;
      var kSMPlayerRunMaxBlocksPerSecond = 12;
      var kSMPlayerChangedDirectionPenalty = 0.125;
      var kSMPlayerSkidDurationInSeconds = 0.35;

      //  Load images
      console.log('Loading images');
      var SMImages = {};
      Array.prototype.slice.apply(document.querySelectorAll('#resources img')).forEach(function(elem) {
        SMImages[elem.id] = elem;
      });
      console.log('Images:', SMImages);

      var SMMetrics = {
        BlockToPx: function(blockValue) {
          return blockValue * kSMEngineBlockSize;
        },
        PxToBlock: function(pxValue) {
          return Math.floor(pxValue / kSMEngineBlockSize);
        }
      };

      defineClass('SMCanvas',  function (aCanvas) {
        this.element = aCanvas;
        this.context = aCanvas.getContext('2d');

//         this.width = SMMetrics.BlockToPx(kSMEngineGameWidth);
        this.width = document.body.clientWidth - 20;
        this.height = SMMetrics.BlockToPx(kSMEngineGameHeight);

        this.element.height = this.height;
        this.element.width = this.width;
        this.element.style.height = this.height + 'px';
        this.element.style.width = this.width + 'px';

        this.clear();
      }, {
        clear: function() {
          this.context.fillStyle = kSMColorSkyBlue;
          this.context.fillRect(0, 0, this.width, this.height);
        }
      });

      ///

      defineClass('SMAgent', function(engine) {
        this.engine = engine;
      }, {
        tick: function() {
          console.log('agent tick');
        }
      });

      defineClass('SMPlayer', 'SMAgent', function(engine, startBlockX, startBlockY) {
        SMAgent.prototype.constructor.apply(this, arguments);

        this.playerImageName = 'player-right';
        this.facingDirection = kSMPlayerFaceRight;
        this.skidStartedAt = null;
        this.hState = kSMPlayerHorizontalStateIdle;
        this.vState = kSMPlayerVerticalStateIdle;
        this.speed = 0;

        this.pxPos = {
          x: SMMetrics.BlockToPx(startBlockX),
          y: SMMetrics.BlockToPx(startBlockY)
        };
      }, {
        draw: function() {

          this.engine.canvas.clear();

          var c = this.engine.canvas.context;
          c.drawImage(SMImages[this.playerImageName], this.pxPos.x, this.pxPos.y);
        },
        updateHState: function() {

          this.playerImageName = (this.facingDirection == kSMPlayerFaceRight) ? 'player-right' : 'player-left';

          var acceleration = this.engine.keyMap[kSMKeyAction] ? kSMPlayerRunAcceleration : kSMPlayerWalkAcceleration;
          var maxSpeed = this.engine.keyMap[kSMKeyAction] ? kSMPlayerRunMaxBlocksPerSecond : kSMPlayerWalkMaxBlocksPerSecond;

          if (this.engine.keyMap[kSMKeyLeft] || this.engine.keyMap[kSMKeyRight]) {
            //  walking/running
            if (this.engine.keyMap[kSMKeyLeft]) {
              this.hState = kSMPlayerHorizontalStateLeft;
              this.facingDirection = kSMPlayerFaceLeft;
            } else {
              this.hState = kSMPlayerHorizontalStateRight;
              this.facingDirection = kSMPlayerFaceRight;
            }

            if (this.speed == 0) {
              this.speed = kSMPlayerInitialSpeed;

              //  Always start out with the walking animation frame
              this.walkState = true;
              this.timeOfLastWalkFrame = new Date;
            } else if (this.hState != kSMPlayerHorizontalStateIdle && this.prevHState != kSMPlayerHorizontalStateIdle && this.hState != this.prevHState) {
              //  Just turned around; cut speed
              this.skidStartedAt = this.engine.tickNumber;
              this.skidDuration = kSMPlayerSkidDurationInSeconds * (this.speed / maxSpeed);
              this.speed = Math.max(1, this.speed * kSMPlayerChangedDirectionPenalty);
            } else {
              this.speed = Math.min(this.speed * acceleration, maxSpeed);
            }

          } else if (this.speed > 0) {
            //  slowing down...
            console.log('slow down');
            this.skidStartedAt = null;

            this.speed = Math.max(0, this.speed * kSMPlayerDeceleration);
            if (this.speed < 1) {
              //  stopped.
              console.log('stopped');
              this.speed = 0;
              this.hState = kSMPlayerHorizontalStateIdle;
            }
          }

          if (this.skidStartedAt) {
            //  see how long it's been
            var timeSinceSkidStarted = (this.engine.tickNumber - this.skidStartedAt) / kSMEngineFPS;

            if (timeSinceSkidStarted <= this.skidDuration) {
              //  Still skidding
              this.playerImageName = (this.facingDirection == kSMPlayerFaceRight) ? 'player-left-skid' : 'player-right-skid';
            } else {
              this.skidStartedAt = null;
            }
          } else if (this.speed) {
            //  See if we want to draw the alterate walk frame

            //  slowest = 0.5 seconds per frame (0.5 * kSMEngineFPS ticks)
            //  fastest = 0.1 seconds per frame (0.1 * kSMEngineFPS ticks)
            var fractionOfFullSpeed = this.speed / kSMPlayerWalkMaxBlocksPerSecond;

            this.timeOfLastWalkFrame = this.timeOfLastWalkFrame || new Date;
            var frameDuration = Math.max((1 / fractionOfFullSpeed) * 15, 60);
            if (new Date - this.timeOfLastWalkFrame > frameDuration) {
              this.timeOfLastWalkFrame = new Date;
              this.walkState = !this.walkState;
            }

            if (this.walkState) {
              this.playerImageName = (this.facingDirection == kSMPlayerFaceRight) ? 'player-right-walk' : 'player-left-walk';
            }
          }

          if (this.speed != 0) {
            //  Move the player

            var magnitude = (this.hState == kSMPlayerHorizontalStateLeft) ? -1 : 1;

            this.pxPos.x += (magnitude * this.speed * kSMEngineBlockSize * kSMFrameUnit);
          }

          this.prevHState = this.hState;
        },
        updateVState: function() {
          //  TODO: falling/jumping
        },
        tick: function() {

          this.updateHState();
          this.updateVState();

          this.draw();
        }
      });

      defineClass('SMMap', function(width, height) {
        this.width = width;
        this.height = height;
      });

      defineClass('SMEngine', function(aCanvas) {
        this.tickNumber = 0;

        this.canvas = new SMCanvas(aCanvas);
        this.registerEventListeners();
        this.agents = [];

        this.map = new SMMap();

        this.player = new SMPlayer(this, 4, 8);
        this.addAgent(this.player);
      }, {
        addAgent: function(anAgent) {
          this.agents.push(anAgent);
        },

        registerEventListeners: function() {
          this.keyMap = {};
          document.addEventListener('keydown', this.onKeyPress.bind(this, true), false);
          document.addEventListener('keyup', this.onKeyPress.bind(this, false), false);

//           window.addEventListener('blur', this.onWindowBlur.bind(this), false);
//           window.addEventListener('focus', this.onWindowFocus.bind(this), false);
        },

        onWindowBlur: function() {
          if (this.runTimer) {
            this.wasRunning = true;
            this.stopRunLoop();
          }
        },

        onWindowFocus: function() {
          if (this.wasRunning) {
            this.startRunLoop();
          }
        },

        onKeyPress: function(keyState, e) {
          this.keyMap[e.keyCode] = keyState;
        },

        tick: function() {
          try {
            this.tickNumber++;

            this.agents.forEach(function(agent) {
              agent.tick();
            });
          } catch (e) {
            console.log('Uncaught exception; halting run loop :(');
            this.stopRunLoop();

            throw e;
          }
        },

        startRunLoop: function() {
          console.log('Starting run loop');
          if (this.runTimer) {
            return;
          }

          this.runTimer = setInterval(this.tick.bind(this), 1000 / kSMEngineFPS);
        },

        stopRunLoop: function() {
          console.log('Stopping run loop');
          clearTimeout(this.runTimer);
          this.runTimer = null;
        }
      });

      var eng = window.eng = new SMEngine(document.getElementById('c'));

      eng.startRunLoop();

    })();
  </script>

</html>